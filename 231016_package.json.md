**23.10.16(월))**
# Dependencies in javaScript
## javaScript package
# npm
## package.json
- 프로젝트가 의존하고 있는 패키지 목록
- 빌드를 언제든 다시 할 수 있게 해 다른 개발자들의 공유를 쉽게 함

## 프로젝트가 가질 수 있는 다양한 종속성 타입
- dependencies: 프로젝트 코드를 호출하는데 있어 필수적으로 의존하고 있는 종속성
- devDependencies: 개발단계에서 필요한 종속성
- peerDependencies: 패키지를 설치하는 다른 개발자들에게 종속성 버전 알림
- optionalDependencies: 옵션 성격의 종속성, 이 종속성을 설치하는데 실패해도 문제 X
- bundleDependencies: 패키지 번들링 시 함께 들어가게 되는 의존성. npm에 있지 않은 제 3의 라이브러리 유용

## package-lock.json
**package.json**이나 **node_modules** 디렉토리가 변할 때 마다 자동으로 생성
- 후속 설치 시에도 동일한 의존성 트리를 생성할 수 있도록 함

## npm ci
package.json에는 명확하게 지정된 버전이 아닌 **시멘틱 버전**으로 작성<br>
-> package.json이 아닌 package-lock.json에 명시된 버전의 변경 없이 설치 수행하는 명령어<br>

- 참고: [자바스크립트 의존성 지옥](https://yceffort.kr/2020/11/javascript-dependency-hell)

<hr>
<br>

**23.10.17(화)**
# 활용 도구 선택시 고려할 사항

<br>
<br>

**23.10.18(수)**
# SDK
**소프트웨어 개발 키트(SDK)**<br>
플랫폼별 구축 도구 세트, 소프트웨어를 개발하고 실행하는 데 필요한 모든 것을 한 곳에서 제공
- 디버거, 컴파일러, 라이브러리 등 포함
- 문서, 튜토리얼 및 가이드와 같은 리소스와 더 빠른 애플리케이션 개발을 위한 api 및 프레임워크가 포함

## 장점
1. 애플리케이션에 통합할 수 있는 사전 빌드된 구성 요소와 라이브러리를 제공하여 개발 효율성을 높임
2. 빠른 배포를 가능하게 함. SDK는 여러 플랫폼을 지원하는 경우가 많기 때문에 개발자는 여러 장치 또는 운영 체제에 빠르게 배포 가능.

## 활용
- 모바일 앱 개발
- 웹 개발
등등 다양한 분야에서 사용!

## SDK와 API의 차이점
- API: 애플리케이션이 서로 통신할 수 있도록 하는 일련의 프로그래밍 명령 / 두 애플리케이션 간의 통신 브리지
- SDK : 타사 도구를 개발자의 환경에 제공

- 참고: [SDK](https://aws.amazon.com/ko/what-is/sdk/)

<br>
<br>

**23.10.19(목)**
# 라우팅
네트워크에서 경로를 선택하는 프로세스<br>
미리 정해진 규칙을 사용하여 상호 연결된 네트워크에서 두 노드 간 통신하는 최상의 경로를 선택하는 프로세스<br>

- 네트워크의 정체 없이 최대한 많은 용량을 사용할 수 있도록 데이터 트래픽을 관리, 네트워크 통신 효율성 높임

## 라우터
컴퓨팅 디바이스와 네트워크를 다른 네트워크에 연결하는 네트워킹 디바이스
## 라우터의 기능
1. 경로 결정: 소스에서 대상으로 이동하는 데이터의 경로 결정
2. 데이터 전달: 데이터를 결정한 경로로 전달하여 최종적으로 대상에 도달하도록 함
3. **로드 밸런싱**: 경우에 따라 라우터가 경로를 사용하여 동일한 데이터 패킷의 여러 사본을 전송할 수 있음 / 데이터 손실로 인한 오류 감서, 이중화 구현, 트래픽 볼륨 관리

<br>
<br>

**23.10.20(금)**
# 라우팅의 특성
## 라우팅 동작방식
### 데이터
- 데이터는 **데이터 패킷**의 형태로 네트워크를 통해 이동
- 헤더: 데이터 패킷에 포함, 패킷의 의도된 대상에 대한 정보가 포함
- 패킷이 대상으로 이동하는 동안 여러 라우터가 패킷을 초당 수백만번 라우팅 
  - 데이터 패킷이 도착하면 라우터는 헤더 패킷을 라우팅 테이블에서 주소 찾기 / 헤더패킷 조회 후, 패킷대상 결정 ->  내부 테이블 조회
  - 이후, 라우터가 패킷을 네트워크 다음 지점으로 전달 (다음 라우터, 또는 다른 디바이스)

## 라우팅 유형
1. 정적 라우팅
네트워크 관리자가 정적 테이블을 사용해 네트워크 경로를 수동으로 구성하고 선택<br>
파라미터 일정하게 유지될 것으로 예상될때 유용<br>

2. 동적 라우팅
실제 네트워크 조건에 따라 런타임에 라우팅 테이블을 만들고 업데이트<br>
동적 라우팅 프로토콜을 사용하여 소스에서 대상까지 가장 빠른 경로를 찾으려고 시도

## 주요 라우팅 프로토콜
라우터가 패킷을 식별하고 네트워크 경로를 따라 전달하는 방법을 지정하는 규칙 set

1. 내부 게이트웨이 프로토콜
단일 조직 관리자가 제어하는 네트워크(자율 시스템)에서 가장 효과적으로 작동<br>
e.g.) Routing information Protocol(홉 수 기준), Open Shortest Path First 프로토콜(모든 라우터 정보 수집해 가장 짧고 빠른 경로 식별)

2. 외부 게이트웨이 프로토콜
두 자율 시스템간 정보전송 관리에 적합<br>
e.g.) Border Gateway Protocol(인터넷을 통한 통신, 가장 가까운 ASN(Autonomous System Number)을 추적하고 대상 주소를 해당 ASN에 매핑)

## 라우팅 알고리즘
- 거리벡터 라우팅(네트워크 모든 라우터가 가능한 모든 대상에 대한 최상의 경로에 대한 정보를 찾음)
- 링크 상태 라우팅(모든 라우터가 네트워크의 다른 모든 라우터를 검색 -> 이 정보로 전체 네트워크 맵을 만들어 패킷 최단경로 계산)

<br>

- 라우팅은 다율 시스템과 인터넷간 데이터 패킷을 전환하는 것을 넘어 클라우드 라우팅으로 진화(가상 네트워크를 구축 및 연결)

-참고: [라우팅이란 무엇입니까?](https://aws.amazon.com/ko/what-is/routing/)

<br>
<br>

**23.10.21(토)**
## 시맨틱 버저닝
semantic versioning<br>
패키지의 버전 표현 방식. 숫자 3자리로 버전을 표현 <br>

### Major Digit (첫번째 숫자)
- 이전 버전들과의 호환성을 나타냄
  - 업데이트시 이전 버전과 호환되지 않는 큰 변화가 있었다면, major digit의 숫자가 커진다 (e.g. 1.0.1 -> 2.0.1)

### Minor Digit (두번째 숫자)
- 업데이트에 새로운 기능이 추가된 경우
- 이전 버전과 호환이 되는 경우 (e.g. 1.0.1 -> 1.1.1)

### Patch Digit (세번째 숫자)
- 새로운 기능의 추가가 아닌 간단한 버그 패치가 있었을 경우 (e.g. 1.0.1 -> 1.0.2)

## package.json의 '^'와 '~'
프로젝트 내부 dependency의 버전을 제한할 것인지 여부 나타냄<br>
정확하게 일치하는 버전을 사용하기보다 **제한된 버전 내에서 최신 버전**을 사용
- **--save** 옵션을 사용하여 dependency를 추가하면 자동으로 **^** 기호가 추가

### ^
```js
"react": "^16.8.6"
// 16.*.*의 버전을 가져올 수 있음
```
- minor digit을 기준으로 최신 패키지 사용 / 호환가능한 최신 기능의 버전으로 업데이트

### ~
```js
"react": "~16.8.6"
// 16.8.*의 버전을 가져올 수 있음
```
- patch digit 기준으로 최신 패키지 사용 / 버그 픽스된 최신 버전으로 업데이트

- 참고: [시멘틱 버저닝](https://jake-seo-dev.tistory.com/283)

<br>
<br>

**23.10.22(일)**
# Third-Party
프로그래밍을 도와주는 플러그인 또는 라이브러리를 만드는 회사<br>
- 주 기술을 보유한 하드웨어 제조사가 기술을 연구하는 것이 아닌 소규모의 개발자들이 주어진 규격에 맞추어 제품을 생산하는 것 
- 소프트웨어들이 모여있는 온라인 스토어와 이들 사용자를 기준으로 하는 어플리케이션 제작자

## First-Party
하드웨어 제조사가 직접 제작한 소프트웨어

## Second-Party
하드웨어 생산자인 모기업과 자사간의 관계에서의 소프트웨어 개발자<br>
퍼스트파티의 자회사는 아니지만 퍼스트 파티의 투자를 받거나 전략적 제휴 등의 이유로, 출시하는 대부분의 소프트웨어를 퍼스트 파티 플랫폼의 독점작으로만 출시하는 회사들

- 참고: [Third-Party란?](https://velog.io/@33bini/CS-Third-party%EC%84%9C%EB%93%9C-%ED%8C%8C%ED%8B%B0)



