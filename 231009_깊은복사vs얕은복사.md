**23.10.09(금)**
# 깊은복사, 얕은복사
## immutable한 객체의 경우
```py
a = 123
b = a
# id(b) = id(a)

b = 1234
print(a) # 123
print(b) # 1234
```

- b에 a를 할당하면 같은 메모리 주소를 향한다.
- 그러나 b에 다른 값을 할당하면 **재할당**이 이루어지며 다른 메모리 주소를 향하게 된다.<br>
(재할당은 깊은복사, 얕은복사와 별개의 문제이다)

## mutable한 객체의 경우
## 얕은복사
```py
a = [1, 2, 3]
b = a 

# id(a) = id(b)
# b에 a를 할당하면 값이 할당되는 것이 아니라, 같은 메모리 주소를 향하게 된다
# 따라서, b의 값을 변경하면 a의 값도 같이 바뀐다.
```

### 슬라이싱
- mutable 객체 안에 mutable 객체가 존재하는 경우
```py
a = [[1, 2], [3]]
b = a[:]

# id(a) != id(b)
a == b # True
a is b # False

# 슬라이싱을 통해 새로운 id가 부여된다
# 그러나 내부의 객체 a[0]과 b[0]은 같은 주소를 바라본다
# id(a[0]) == id(b[0])
```
- 슬라이싱의 경우, 재할당하면 메모리 주소도 변경된다
```py
a[0] = [4, 5]
print(a) # [[4, 5], [3]]
print(b) # [[1, 2], [3]]
```

### copy 메소드
```py
import copy

a = [[1, 2], [3]]
b = copy.copy(a)

# id(a) == id(b)
a[1].append(4)
print(a) # [[1, 2], [3, 4]]
print(b) # [[1, 2], [3, 4]]
```

## 깊은 복사
내부 객체들까지 모두 새롭게 copy
### deepcopy 메소드
```py
import copy

a = [[1, 2], [3]]
b = copy.deepcopy(a)

# id(a) == id(b)
a[1].append(4)
print(a) # [[1, 2], [3, 4]]
print(b) # [[1, 2], [3]]
```