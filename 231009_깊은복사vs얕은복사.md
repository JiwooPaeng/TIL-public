**23.10.09(월))**
# 깊은복사, 얕은복사
## immutable한 객체의 경우
```py
a = 123
b = a
# id(b) = id(a)

b = 1234
print(a) # 123
print(b) # 1234
```

- b에 a를 할당하면 같은 메모리 주소를 향한다.
- 그러나 b에 다른 값을 할당하면 **재할당**이 이루어지며 다른 메모리 주소를 향하게 된다.<br>
(재할당은 깊은복사, 얕은복사와 별개의 문제이다)

## mutable한 객체의 경우
## 얕은복사
```py
a = [1, 2, 3]
b = a 

# id(a) = id(b)
# b에 a를 할당하면 값이 할당되는 것이 아니라, 같은 메모리 주소를 향하게 된다
# 따라서, b의 값을 변경하면 a의 값도 같이 바뀐다.
```

### 슬라이싱
- mutable 객체 안에 mutable 객체가 존재하는 경우
```py
a = [[1, 2], [3]]
b = a[:]

# id(a) != id(b)
a == b # True
a is b # False

# 슬라이싱을 통해 새로운 id가 부여된다
# 그러나 내부의 객체 a[0]과 b[0]은 같은 주소를 바라본다
# id(a[0]) == id(b[0])
```
- 슬라이싱의 경우, 재할당하면 메모리 주소도 변경된다
```py
a[0] = [4, 5]
print(a) # [[4, 5], [3]]
print(b) # [[1, 2], [3]]
```

### copy 메소드
```py
import copy

a = [[1, 2], [3]]
b = copy.copy(a)

# id(a) == id(b)
a[1].append(4)
print(a) # [[1, 2], [3, 4]]
print(b) # [[1, 2], [3, 4]]
```

## 깊은 복사
내부 객체들까지 모두 새롭게 copy
### deepcopy 메소드
```py
import copy

a = [[1, 2], [3]]
b = copy.deepcopy(a)

# id(a) == id(b)
a[1].append(4)
print(a) # [[1, 2], [3, 4]]
print(b) # [[1, 2], [3]]
```

<br>
<hr>
<br>

**23.10.10(화)**
# 구조분해할당
**배열이나 객체의 속성을 해체**하여 그 값을 **개별 변수**에 담을 수 있게 하는 표현식
```js
var a, b, rest;
[a, b] = [10, 20];
console.log(a); // 10
console.log(b); // 20

var x = [1, 2, 3, 4, 5];
var [y, z] = x;
console.log(y); // 1
console.log(z); // 2

[a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a); // 10
console.log(b); // 20
console.log(rest); // [30, 40, 50]


// 객체 구조 분해
({ a, b } = { a: 10, b: 20 });
console.log(a); // 10
console.log(b); // 20

({ a, b, ...rest } = { a: 10, b: 20, c: 30, d: 40 });
console.log(a); // 10
console.log(b); // 20
console.log(rest); // {c: 30, d: 40}
```
### for of 반복문과 구조분해
```js
var people = [
  {
    name: "Mike Smith",
    family: {
      mother: "Jane Smith",
      father: "Harry Smith",
      sister: "Samantha Smith",
    },
    age: 35,
  },
  {
    name: "Tom Jones",
    family: {
      mother: "Norah Jones",
      father: "Richard Jones",
      brother: "Howard Jones",
    },
    age: 25,
  },
];

for (var {
  name: n,
  family: { father: f },
} of people) {
  console.log("Name: " + n + ", Father: " + f);
}

// "Name: Mike Smith, Father: Harry Smith"
// "Name: Tom Jones, Father: Richard Jones"
```

- 참고: [구조분해할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

<br>
<hr>
<br>

**23.10.11(수)**
# MPA & SPA
## 웹애플리케이션
웹 브라우저에서 실행되며, 웹 서버와 통신하여 사용자와 상호 작용하는 소프트웨어.

## MPA (Multiple Page Application)
여러개의 페이지로 구성된 웹애플리케이션<br>
- 여러 페이지로 이루어져 각 페이지가 새로운 HTML을 로드하여 화면을 갱신하는 전통적인 웹 애플리케이션 형태
- 새로운 페이지를 요청할 때마다 서버에서 페이지를 렌더링하고 전달

### 특징
- **검색 엔진 최적화(SEO)**: 완성된 형태의 HTML 파일을 서버로부터 전달받기 때문에 검색 엔진이 콘텐츠를 쉽게 크롤링하고 인덱싱
- 초기 로딩시, 각 페이지가 별도로 렌더링되기 때문에 초기 로딩 속도가 상대적으로 빠름
- 페이지 간 이동시마다 서버에서 새로운 HTML을 받아야하므로 페이지간 이동 지연 및 서버 부하 발생 가능성이 존재


## SPA (Single Page Application)
하나의 페이지로 구성된 웹애플리케이션<br>
- 하나의 HTML 페이지로 시작하고 js를 사용해 필요한 데이터를 동적으로 로드
- 클라이언트 측에서 페이지간 이동을 처리해 빠른 성능과 부드러운 사용자 경험을 제공

### 특징
- 초기 페이지 로드 이후, 필요한 데이터만 가져오므로 초기 로딩이 빠름
- 초기 페이지 로딩은 빠르지만, 페이지 로드에 필요한 js 및 데이터 다운 과정에서 지연 발생
- 페이지를 다시 로드하지 않아도 빠르고 부드럽게 페이지 이동 및 데이터 업데이트 가능

## MPA/SPA와 SSR/CSR의 관계
MPA는 일반적으로 SSR과 함께 사용되고, SPA는 주로 CSR 방식을 사용하지만<br>
둘의 관계가 절대적인 것은 아니다!
e.g.) MPA 페이지를 구현하면서도, AJAX를 이용하여 동적으로 로드되는 데이터를 포함하는 등 CSR을 함께 활용 가능

<br>
<hr>
<br>

**23.10.12(목)**
# 데스크톱 앱
## 앱
응용 프로그램. 응용 프로그램, 응용 소프트웨어 <br>

## 웹앱
인터넷을 통해 웹 페이지처럼 사용할 수 있는 응용 프로그램
- 서버를 통해 게시

## 데스크톱 앱
로컬, 즉 사용자의 컴퓨터에 설치되고 실행되는 응용 프로그램
- 수동 설치

## 최신 기술 솔루션
## PWA
Progressive Web Apps (프로그레시브 웹 앱)<br>
### 장점
데스크톱과 모바일 기기 모두 설치 가능<br>
OS 기능에 대한 엑세스와 같은 이점을 제공하는 강력한 **under-the hood** 기능중 일부 누락

## Desktop Container
자바스크립트, HTML, CSS와 같은 웹 기술을 사용하여 데스크톱 앱을 작성할 수 있는 프레임워크 <br>
e.g. Electron(일렉트론)
- 단일 코드베이스로 데스크톱 앱과 웹 앱을 모두 쉽게 유지 관리 가능
- PWA에 비해 알림, 파일 시스템 및 다중 창 관리와 같은 OS 기능에 엑세스 할 수 있는 장점

- 참고: [웹 앱vs데스크톱 앱.우리 앱은 뭘로 만들어야하죠?](https://jiyu0719.medium.com/%EC%9B%B9-%EC%95%B1-vs-%EB%8D%B0%EC%8A%A4%ED%81%AC%ED%86%B1-%EC%95%B1-%EC%9A%B0%EB%A6%AC-%EC%95%B1%EC%9D%80-%EB%AD%98%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%95%BC%ED%95%98%EC%A3%A0-4557b69fa98d)

<br>
<hr>
<br>

**23.10.13(금)**
# 컴파일
## Compile
- 인간이 이해할 수 있는 언어로 작성된 소스 코드(고수준 언어)를 CPU가 이해할 수 있는 언어(저수준 언어:기계코드, 이진코드)로 번역하는 작업
- **assembling** / **build** 작업은 보통 컴파일과 같은 작업 수행


## Compiler
컴파일을 실행하는 소프트웨어<br>
- 컴파일러는 고급언어로의 번역을 하는 역할도 함 → 이 경우 종종 **트랜스파일러**라고 함
- e.g. TypeScript에서 JavaScript로, 타입스크립트 컴파일러를 통해 고급 언어로의 번역

<br>
<hr>
<br>

**23.10.14(토)**
# 팀 프로젝트
지난했던 기획 주간을 마무리하며...

## 팀 프로젝트를 통해 배울 수 있었던 점들
1. 새로운 기술 학습<br>
새롭게 익혀보고 싶은 기술들을 프로젝트에 실제로 적용해보면서, 기술에 대한 이해도를 높일 수 있었다. 뿐만 아니라, 기술 활용시 발생하는 다양한 기술적 문제들을 접하고 회의 및 조사를 통해 문제를 해결하며 기술 학습 및 문제 해결에 대한 방법을 익히고 경험도 쌓을 수 있어 개발자로서 한층 성장할 수 있었다.

2. 팀원간 상황 공유와 소통<br>
다양한 팀원들의 의견을 꼼꼼히 들으며, 프로젝트의 진행 상황 및 개인 진행정도륵 파악하며 적재적소에 활동을 제시, 또는 진행하는 등 팀 프로젝트는 함께 보폭을 맞춰 걸어나가는 과정임을 느꼈다. 너무 혼자 독단적으로 개발 또는 기획을 진행하거나 또는 현재 진행하고 있는 사항을 공유하지 않으면 아무리 빠른 진행으로 프로젝트의 완성시기를 앞당겼다 하더라도 전체적인 팀 프로젝트에서 볼때 불편감을 줄 수 있음을 느꼈다. 스스로의 상황을 어떻게하면 팀원 모두에게 조금 더 잘 와닿게 전달할 수 있을지 고민하는 계기가 되었다.

3. 소통의 방식<br>
나는 적극적이고자하면 매우 이성적으로 접근하는 측면이 있다. 다소 성급하고, 배려보다는 일의 진행과 객관성을 내세우는 경향이있어 내가 팀원들에게 했던 행동을 되돌아봤을때, 괜히 나섰다, 그런식의 반응때문에 불편하지는 않았을까, 나의 평판에 부정적인 영향을 줄만한 행동을 한 것 같다는 생각을 꽤나 자주하고는 한다. 내뱉은 말은 주워담을 수 없기에 행동을 한번 할때 주의하려고는 하지만, 아무래도 프로젝트를 진행하다보면 체력에 부쳐서 다소 충분히 신경쓰지 못하고 말을 뱉거나 행동할때가 많다. 이기적이고, 날카롭게 상황을 분석해야하는 상황이 존재하기 마련이지만, 차분하게 나의 의견을 피력하고 침착하게 상황을 이끌어나가는 능력을 길러야 겠다. 

4. 신뢰<br>
팀 프로젝트에서 무엇보다 중요하다고 느끼는 것 중 하나가 바로 팀원간의 신뢰다. 해당 팀원이 특정 업무를 맡았다면, 그 업무 만큼은 최선을 다해 그리고 '잘' 진행할 것이라는 믿음. 뿐만 아니라, 상대 팀원이 나를 이러한 방식으로 신뢰하고 있을것이라는 믿음. 팀워크 뿐만 아니라 모든 인간관계에서 가장 중요하다고 생각하는 포인트가 바로 신뢰이다. 개인적으로 상대 팀원이 나에 대해 신뢰하지 않을것이라는 의심이 싹트기 시작했을때 무엇보다도 팀 프로젝트에 대한 열정이 감소하고 욕심과 승부욕에 사로잡히는 경향이 있었다. 물론 그것이 작업에 대한 순간의 집중력을 높여주기도 했지만, 길게 봤을때 팀의 프로젝트에 대한 자신감을 떨어뜨리고 번아웃을 초래했다. 나부터라도 상대방에대해 적극적으로 믿음을 보여주고, 다소 서로 맞지 않더라도 유연하게 대처하고 관계를 잘 이끌어나가야 겠다는 다짐을 하는 계기가 되었다.

5. 일정 공유 및 개인 시간의 분배<br>
팀 프로젝트는 함께 공유하는 시간이 많기 때문에 각자의 개인 일정 공유 및 미리 시간을 분배해 놓는 작업이 필수이다. 만약 이 작업이 충분히 이루어지지 못했을때 앞서 말한 신뢰 관계가 약해지거나, 작업이 지연되고 이에따라 팀원 전체가 지치는 결과를 초래한다. 따라서, 팀 프로젝트를 위해서는 반드시 사전에 미리 팀을 위해 쓸 수 있는 시간을 공유해야 함을 느꼈다. 또한, 너무 개인시간을 팀 프로젝트에 오롯이 쏟는 것도 개인의 측면에서 봤을때 결과적으로 번아웃을 초래하고 개인의 건강을 해친다는 것을 새삼스레 배웠다. 따라서, 나의 시간을 현명하게 나눠쓰기 위해 내가 했던, 그리고 할 작업들을 잘 기록하고 계획하기 시작했다.

마지막 팀 프로젝트를 마치고, 새로운 회사에서 새로운 사람들과 빠른시일내에 또 함께 작업할 수 있기를 고대하며..