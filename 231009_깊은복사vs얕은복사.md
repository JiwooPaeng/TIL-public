**23.10.09(월))**
# 깊은복사, 얕은복사
## immutable한 객체의 경우
```py
a = 123
b = a
# id(b) = id(a)

b = 1234
print(a) # 123
print(b) # 1234
```

- b에 a를 할당하면 같은 메모리 주소를 향한다.
- 그러나 b에 다른 값을 할당하면 **재할당**이 이루어지며 다른 메모리 주소를 향하게 된다.<br>
(재할당은 깊은복사, 얕은복사와 별개의 문제이다)

## mutable한 객체의 경우
## 얕은복사
```py
a = [1, 2, 3]
b = a 

# id(a) = id(b)
# b에 a를 할당하면 값이 할당되는 것이 아니라, 같은 메모리 주소를 향하게 된다
# 따라서, b의 값을 변경하면 a의 값도 같이 바뀐다.
```

### 슬라이싱
- mutable 객체 안에 mutable 객체가 존재하는 경우
```py
a = [[1, 2], [3]]
b = a[:]

# id(a) != id(b)
a == b # True
a is b # False

# 슬라이싱을 통해 새로운 id가 부여된다
# 그러나 내부의 객체 a[0]과 b[0]은 같은 주소를 바라본다
# id(a[0]) == id(b[0])
```
- 슬라이싱의 경우, 재할당하면 메모리 주소도 변경된다
```py
a[0] = [4, 5]
print(a) # [[4, 5], [3]]
print(b) # [[1, 2], [3]]
```

### copy 메소드
```py
import copy

a = [[1, 2], [3]]
b = copy.copy(a)

# id(a) == id(b)
a[1].append(4)
print(a) # [[1, 2], [3, 4]]
print(b) # [[1, 2], [3, 4]]
```

## 깊은 복사
내부 객체들까지 모두 새롭게 copy
### deepcopy 메소드
```py
import copy

a = [[1, 2], [3]]
b = copy.deepcopy(a)

# id(a) == id(b)
a[1].append(4)
print(a) # [[1, 2], [3, 4]]
print(b) # [[1, 2], [3]]
```

<br>
<hr>
<br>

**23.10.10(화)**
# 구조분해할당
**배열이나 객체의 속성을 해체**하여 그 값을 **개별 변수**에 담을 수 있게 하는 표현식
```js
var a, b, rest;
[a, b] = [10, 20];
console.log(a); // 10
console.log(b); // 20

var x = [1, 2, 3, 4, 5];
var [y, z] = x;
console.log(y); // 1
console.log(z); // 2

[a, b, ...rest] = [10, 20, 30, 40, 50];
console.log(a); // 10
console.log(b); // 20
console.log(rest); // [30, 40, 50]


// 객체 구조 분해
({ a, b } = { a: 10, b: 20 });
console.log(a); // 10
console.log(b); // 20

({ a, b, ...rest } = { a: 10, b: 20, c: 30, d: 40 });
console.log(a); // 10
console.log(b); // 20
console.log(rest); // {c: 30, d: 40}
```
### for of 반복문과 구조분해
```js
var people = [
  {
    name: "Mike Smith",
    family: {
      mother: "Jane Smith",
      father: "Harry Smith",
      sister: "Samantha Smith",
    },
    age: 35,
  },
  {
    name: "Tom Jones",
    family: {
      mother: "Norah Jones",
      father: "Richard Jones",
      brother: "Howard Jones",
    },
    age: 25,
  },
];

for (var {
  name: n,
  family: { father: f },
} of people) {
  console.log("Name: " + n + ", Father: " + f);
}

// "Name: Mike Smith, Father: Harry Smith"
// "Name: Tom Jones, Father: Richard Jones"
```

- 참고: [구조분해할당](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)

<br>
<hr>
<br>

**23.10.10(화)**
# MPA & SPA
## 웹애플리케이션
웹 브라우저에서 실행되며, 웹 서버와 통신하여 사용자와 상호 작용하는 소프트웨어.

## MPA (Multiple Page Application)
여러개의 페이지로 구성된 웹애플리케이션<br>
- 여러 페이지로 이루어져 각 페이지가 새로운 HTML을 로드하여 화면을 갱신하는 전통적인 웹 애플리케이션 형태
- 새로운 페이지를 요청할 때마다 서버에서 페이지를 렌더링하고 전달

### 특징
- **검색 엔진 최적화(SEO)**: 완성된 형태의 HTML 파일을 서버로부터 전달받기 때문에 검색 엔진이 콘텐츠를 쉽게 크롤링하고 인덱싱
- 초기 로딩시, 각 페이지가 별도로 렌더링되기 때문에 초기 로딩 속도가 상대적으로 빠름
- 페이지 간 이동시마다 서버에서 새로운 HTML을 받아야하므로 페이지간 이동 지연 및 서버 부하 발생 가능성이 존재


## SPA (Single Page Application)
하나의 페이지로 구성된 웹애플리케이션<br>
- 하나의 HTML 페이지로 시작하고 js를 사용해 필요한 데이터를 동적으로 로드
- 클라이언트 측에서 페이지간 이동을 처리해 빠른 성능과 부드러운 사용자 경험을 제공

### 특징
- 초기 페이지 로드 이후, 필요한 데이터만 가져오므로 초기 로딩이 빠름
- 초기 페이지 로딩은 빠르지만, 페이지 로드에 필요한 js 및 데이터 다운 과정에서 지연 발생
- 페이지를 다시 로드하지 않아도 빠르고 부드럽게 페이지 이동 및 데이터 업데이트 가능

## MPA/SPA와 SSR/CSR의 관계
MPA는 일반적으로 SSR과 함께 사용되고, SPA는 주로 CSR 방식을 사용하지만<br>
둘의 관계가 절대적인 것은 아니다!
e.g.) MPA 페이지를 구현하면서도, AJAX를 이용하여 동적으로 로드되는 데이터를 포함하는 등 CSR을 함께 활용 가능